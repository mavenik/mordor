#define UUID_BYTE_LENGTH 16 // UUIDs in binary form are 16 bytes long

/**
 * Fills a byte sequence of 16 bytes with random hex values
 * 
 * @param uint8_t * byteArray to be filled
 */
void memfill(uint8_t* byteArray)
{
  int size;// we will process 32 bit words generated by esp_random;
  for(size = 0; size < (UUID_BYTE_LENGTH / 4); size++)
  {
    // Generate a 32-but random word
    uint32_t randomWord = esp_random();

    // Read it as a sequence of four 8-bits (1 byte each)
    uint8_t *bytes = (uint8_t*)&randomWord;
    int byteCount;
    for(byteCount=0; byteCount < (32/8); byteCount++)
    {
      *byteArray = *bytes;
      bytes++;
      byteArray++;
    }
  }

  // Add version number as 4
  byteArray[6] = 0x40 | (0x0F & byteArray[6]);
  byteArray[8] = 0x80 | (0x3F & byteArray[8]);
  
}

/** 
 * Converts a byte into hex string
 * 
 * @param byte number
 * @return char * Hex string of two characters (one byte from 00 to ff can be represented in two characters)
 */
    char* hexString(byte number)
  {
    int topDigit = number >> 4;
    int bottomDigit = number & 0x0f;
    char *charByte = (char*)malloc(2*sizeof(char));

    charByte[0] = "0123456789abcdef"[topDigit];
    charByte[1] = "0123456789abcdef"[bottomDigit];

    return charByte;
    }

/**
 * Returns a version 4 UUID as per RFC4122 (http://tools.ietf.org/html/rfc4122)
 */
  char * uuidv4()
  {
    int uuidLength = 36;
    char * uuidString = (char*)malloc((uuidLength+1)*sizeof(char));
    byte uuidNumber[UUID_BYTE_LENGTH];
    memfill(uuidNumber);
    
    int byteCounter;
    for (byteCounter = 0; byteCounter < 16; byteCounter++) {
      if(byteCounter == 4 || byteCounter == 6 || byteCounter == 8 || byteCounter == 10)
      {
        *uuidString = '-';
        uuidString++;
        }
        char * charByte = hexString(uuidNumber[byteCounter]);
        *uuidString = *charByte;
        uuidString++; charByte++;
        *uuidString = *charByte;

        uuidString++;
      }
      *uuidString = '\0';

      return uuidString - uuidLength;
  }
